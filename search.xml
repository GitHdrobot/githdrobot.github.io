<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Build Your Blog</title>
      <link href="/2021/11/11/build-github-blog-with-hexo/"/>
      <url>/2021/11/11/build-github-blog-with-hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-搭建github博客"><a href="#hexo-搭建github博客" class="headerlink" title="hexo 搭建github博客"></a>hexo 搭建github博客</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="GitHub账号"><a href="#GitHub账号" class="headerlink" title="GitHub账号"></a>GitHub账号</h3><ul><li>申请GitHub账号</li><li>创建username.github.io仓库</li></ul><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ul><li>安装node.js</li><li>安装git</li></ul><h2 id="配置SSH-key"><a href="#配置SSH-key" class="headerlink" title="配置SSH key"></a>配置SSH key</h2><ul><li>在git bash中执行下面命令，连续回车3次</li></ul><pre class=" language-shell"><code class="language-shell">ssh-keygen -t rsa -C "邮件地址"</code></pre><ul><li>将文件~/.ssh/id_rsa.pub文件中的公钥添加到GitHub中</li><li>git bash 中执行下列命令，测试SSH配置是否正确</li></ul><pre class=" language-shell"><code class="language-shell">ssh -T git@github.com</code></pre><ul><li>设置邮箱、用户名</li></ul><pre class=" language-shell"><code class="language-shell">git config --global user.name "xxx"// xxx为github用户名git config --global user.email  "xxx@163.com"// github注册邮箱</code></pre><h2 id="使用hexo写博客"><a href="#使用hexo写博客" class="headerlink" title="使用hexo写博客"></a>使用hexo写博客</h2><h3 id="什么是hexo"><a href="#什么是hexo" class="headerlink" title="什么是hexo"></a>什么是hexo</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用&nbsp;<a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>更多: <a href="https://hexo.io/docs/">Get Started</a></p><h3 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h3><pre class=" language-shell"><code class="language-shell">npm install -g hexo-clihexo init</code></pre><h3 id="hexo网站目录结构"><a href="#hexo网站目录结构" class="headerlink" title="hexo网站目录结构"></a>hexo网站目录结构</h3><pre class=" language-json"><code class="language-json">.├── _config.yml             网站配置文件 ├── package.json            应用程序信息├── scaffolds               模板文件夹├── source                  资源文件夹|   ├── _drafts|   └── _posts└── themes                  主题文件夹</code></pre><h1 id="编辑文档"><a href="#编辑文档" class="headerlink" title="编辑文档"></a>编辑文档</h1><ul><li>hexo new [layout] title                 创建文档，layout默认为post</li><li>使用编辑工具编辑创建的文档 </li><li>hexo generate                             生成静态文件</li><li>hexo clean &amp;&amp; hexo deploy        部署到服务器</li></ul><p>更多参见 <a href="https://hexo.io/docs">hexo doc</a></p><h1 id="hexo-升级"><a href="#hexo-升级" class="headerlink" title="hexo 升级"></a>hexo 升级</h1><pre class=" language-shell"><code class="language-shell">npm install -g npm-check-updatesncuncu -u# 以下命令用来解决依赖问题，非必须，视实际环境执行npm audit fixnpm auditnpm update kind-of --depth 10</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web Design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Markdown </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/11/11/hello-world/"/>
      <url>/2021/11/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.<br>Welcome</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ExecutableFile</title>
      <link href="/2021/11/07/executablefile/"/>
      <url>/2021/11/07/executablefile/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>可执行文件是指可被某个平台加载执行的文件，分为编译型执行文件和解释型脚本文件，本文仅对编译文件进行说明。不同平台的可执行文件格式差别较大，可执行文件也是相对的。例如：对于Windows平台，Windows系统负责载入并执行.exe文件，.exe在windows系统下是可执行文件。相对于引导程序，Windows系统则是可执行文件，只是两者执行环境、扮演的角色不同。常见的可执行文件格式如下表：</p><table><thead><tr><th>简称</th><th>全称</th><th>系统</th><th>扩展名</th><th>查看工具</th></tr></thead><tbody><tr><td>COFF</td><td>Common Object File Format</td><td>Unix Like、Embedded Platform</td><td>.obj</td><td>objdump,dumpbin</td></tr><tr><td>PE</td><td>Portable Executable</td><td>Windows</td><td>.exe,.dll</td><td>PETool</td></tr><tr><td>ELF</td><td>Executable and Linkable</td><td>Linux、Unix Like</td><td>.o,.so</td><td>objdump,readelf</td></tr><tr><td>Mach-O</td><td>Mach Object</td><td>Mac OS</td><td>dylib</td><td>otool、MachOView</td></tr></tbody></table><p>可使用转换工具将不同格式的目标文件进行相互转换<a href="!https://github.com/gitGNU/objconv">objconv</a>。</p><h3 id="COFF"><a href="#COFF" class="headerlink" title="COFF"></a>COFF</h3><p>通用目标文件格式，最早在Unix System V中使用，主要用于可执行文件、目标文件、共享库文件的一种文件格式。</p><table><thead><tr><th>文件结构</th><th>位置</th><th>作用</th></tr></thead><tbody><tr><td>文件头</td><td>文件开始处</td><td>文件概览，控制其他节的布局</td></tr><tr><td>可选头</td><td>文件头后面</td><td>存放文件执行相关信息</td></tr><tr><td>节头</td><td>可选头后面，数量由文件头决定</td><td>维护代码节、数据节位置、大小相关信息</td></tr><tr><td>节数据</td><td>存放在节头中，由节头指定</td><td>包含程序数据、代码</td></tr><tr><td>重定位指令</td><td>存放在节头中，由节头指定</td><td>包含重定位节所需要的相关信息</td></tr><tr><td>行数</td><td>存放在节头中，由节头指定</td><td>存放每个符号的行号</td></tr><tr><td>符号表</td><td>存放在文件头中</td><td>包含文件定义、引用的每个符号</td></tr><tr><td>字符串表</td><td>符号表后面</td><td>存放符号名称</td></tr></tbody></table><p>当前使用更多的是COFF文件格式的变种，如Windows系统PE、Linux的ELF、MacOS的Mach-O，以及其他类Unix环境，嵌入式环境（XCOFF、ECOFF），大多格式都包含上述结构。</p><img src="PE_COFF_FileHeader.png" alt="PE COFF File Header" style="zomm:%100;"><h3 id="PE"><a href="#PE" class="headerlink" title="PE"></a>PE</h3><p>PE文件文件头由MS-DOS信息、PE签名信息、COFF文件头、可选头，可选头中一般存放着ms定义的信息。PE格式最新介绍见ms文档说明<a href="https://docs.microsoft.com/zh-cn/windows/win32/debug/pe-format">PE 文件格式</a>和[PE文件细节](<a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2002/february/inside-windows-win32-portable-executable-file-format-in-detail">Inside Windows: Win32 Portable Executable File Format in Detail | Microsoft Docs</a>)。</p><p>此处以vs编译出一可执行文件为例，其布局如下图</p><img src="EXE_Format_example.png" alt="EXE_Format_example" style="zomm:%100;"><img src="Portable_Executable_32_bit_Structure_in_SVG_fixed.svg" alt="PE_Structure" style="zomm:%100;"><p>若是.NET程序其文件结构基于PE格式，只是在其中增加了CLR头和CLR数据。</p><img src="Net_PE_file.JPG" alt="NET_File_Structure" style="zomm:%100;"><h3 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h3><p>一个ELF（Executable and Link able Forma）文件由ELF文件头和数据组成，数据包括了程序头表：描述了文件如何被加载到内存，节头表：描述了文件中的节表如何被链接器链接，以及数据，数据只能属于程序头表或者节头表，ELF文件可分别从执行视图和链接视图的角度进行分析。</p><img src="Elf-layout--en.svg" alt="ELF_Layout" style="zomm:%100;"><img src="ELF_Executable_and_Linkable_Format_diagram_by_Ange_Albertini.png" alt="ELF_Structure" style="zomm:%100;"><p>ELF文件被设计为便捷、可扩展、跨平台的格式，可以应用在不同大小端、不同处理器、不同指令集、不同操作系统中，这些属性在ELF结构中都有相应的字段进行描述。</p><h3 id="Mach-O"><a href="#Mach-O" class="headerlink" title="Mach-O"></a>Mach-O</h3><p>Mach-O格式主要应用与OSX、macOS、IOS系统中，Mach-O文件由Mach-O头、加载命令、一个或多个段（每个段由0~255个节组成）几部分组成。采用胖二进制格式，即包含完整的多个平台架构的程序</p><img src="Mach-O-Format.jpg" alt="Mach-O-Format" style="zomm:%100;"><img src="Mach-O-example.png" alt="Mach-O-example" style="zomm:%100;">]]></content>
      
      
      
        <tags>
            
            <tag> COFF </tag>
            
            <tag> PE </tag>
            
            <tag> ELF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Compile</title>
      <link href="/2021/10/11/compile/"/>
      <url>/2021/10/11/compile/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>编译这个词是随着近代计算机科学的发展而发明的，为“偷懒”而发明了编译器。其实质工作就是将易于编程人员理解的语言翻译为计算机能理解的机器语言，从这个角度看似乎叫翻译器更为合适，但现今编译器功能已不仅仅只是简单翻译，还提供了优化、链接、代码检查等多种功能。</p><p>计算机语言一般分为两种“编译”型和“解释”型，两者的主要区别是对程序的处理方式不同，“编译”型语言是将程序一次性“翻译”完成，再将程序载入执行，有点像翻译某个著作的过程，编译和执行是相对独立操作，如C、C++等；“解释”型语言则是一边“翻译”一边执行，有点像同声翻译的过程，解释和执行是交叉进行的，如一些脚本语言。不管是哪一种语言，“翻译”的角色都必不可少，编译型语言需要编译器（GCC、VS、C++ builder），解释型语言需要解释器（V8），还有同时属于这两种的语言Java，Java先统一编译为一种中间语言（字节码），再由Java虚拟机解释执行，从编程人员的角度看他是编译型语言，从计算机的角度看他确实解释型语言。随着计算机的发展，执行速度、内存不再是瓶颈，软件开发重心将会从执行效率向开发效率倾斜，从语言进化的角度看，未来解释型语言将会逐步丰富，编译型语言将仅存在于专业领域。</p><img src="Compiler-vs-interpreter.png" alt="Compiler vs Interpreter" style="zomm:%100;"><h3 id="编译的由来"><a href="#编译的由来" class="headerlink" title="编译的由来"></a>编译的由来</h3><p>谈到编译则不得不提到一位传奇计算机科学家——<a href="https://bcc16.ncu.edu.tw/pool/3.06.shtml">格蕾丝·赫柏</a> (Grace Hopper)，这位提出了编译的概念并创造了第一个编译器程序，发现了第一只bug，因此调试程序称作Debug（国内也有四阿哥专治八阿哥一说 ），主导研制了COBOL语言，耶鲁首位女博士，A国第一位女少将。<a href="ghc.anitab.org">Grace Hopper Celebration of Women in Computing-计算机程序媛大会</a>，Grace Hopper Award（第一个奖颁给了编著计算机程序设计的艺术的高德纳）。</p><img src="First_Computer_Bug_1945.jpg" alt="First Computer Bug 1945" style="zomm:%100;"><img src="Grace_Hopper_and_UNIVAC.jpg" alt="Grace Hopper and UNIVAC" style="zomm:%100;"><p>Grace Hopper说了很多挺有意味的语录，流传比较广的有如下一些：</p><pre class=" language-cobol"><code class="language-cobol">A ship in port is safe, but that’s not what ships are built for.The only phrase I’ve ever disliked is, ‘Why, we’ve always done it that way.’ I always tell young people, ‘Go ahead and do it. You can always apologize later.'One accurate measurement is worth a thousand expert opinions.Leadership is a two-way street, loyalty up and loyalty down. Respect for one’s superiors; care for one’s crew.I’ve always been more interested in the future than in the past.The glass is neither half empty nor half full. It’s simply larger than it needs to be.If you do something once, people will call it an accident. If you do it twice, they call it a coincidence. But do it a third time and you’ve just proven a natural law!In pioneer days they used oxen for heavy pulling, and when one ox couldn’t budge a log, they didn’t try to grow a larger ox. We shouldn’t be trying for bigger computers, but for more systems of computers.Manage things. Lead people.We’ve tended to forget that no computer will ever ask a new question.If it isn’t bolted down, bring it home.I will not take what you need to give me. I will take what you want to give me.To me programming is more than an important practical art. It is also a gigantic undertaking in the foundations of knowledge.</code></pre><h3 id="编译的含义"><a href="#编译的含义" class="headerlink" title="编译的含义"></a>编译的含义</h3><p>$$<br>compile = com + pile<br>$$</p><p>com:  with, together，pile:  a collection of objects laid on top of each other</p><p>compile:  To put together; to assemble; to make by gathering things from various sources.</p><p>将各个资料放在一起，从这堆资料中收集、组装、生产出某个产品。</p><p>编译器从其作用看是编程人员与计算机之间的翻译者，从其产品属性看是按照一定的规范（xx语言标准）生产出的产品，即某种语言的实现。</p><p>下图为编译的一般过程：</p><img src="compiling.gif" alt="Compiling" style="zomm:%100;"><h3 id="常见编译器"><a href="#常见编译器" class="headerlink" title="常见编译器"></a>常见编译器</h3><p>编译器大致分为桌面平台和嵌入式平台两大类，嵌入式平台编译器种类繁多一般各个Soc厂家都会提供自己的编译器，而桌面平台则相对较少，常见的如下表：</p><table><thead><tr><th>名称</th><th></th></tr></thead><tbody><tr><td>GCC（GNU Compiler Collection，GNU编译器套件）</td><td>支持C, C++, Objective-C, Fortran, Ada, Go、D，对C标准的支持是最快的，windows、Linux、嵌入式平台都有应用</td></tr><tr><td>Visual C++</td><td>windows平台的首选开发工具，功能齐全IDE——visual studio</td></tr><tr><td>AOCC、ICC</td><td>AMD、Intel针对各自处理器开发的编译器</td></tr><tr><td>Clang（LLVM）</td><td>是一个C、C++、Objective-C和Objective-C++编程语言的前端，采用LLVM作为编译器后端。其核心是IR（Intermediate Representation：中间语言），一种类似于汇编的底层语言。</td></tr><tr><td>C++ builder</td><td>由Borland开发的针对windows平台的编译器。（vs团队中有部分人员来自Borland公司）</td></tr></tbody></table><h3 id="编译器的组成"><a href="#编译器的组成" class="headerlink" title="编译器的组成"></a>编译器的组成</h3><p>编译器整体架构分为前端和后端（或者分析和综合），一般以中间语言（IR）为分界，前端将高级语言通过词法分析、语法分析、语义分析翻译为中间语言，后端则将中间语言翻译为目标代码。词法分析器（lex, flex, oolex, quex, ml-lex etc.），将源码按字符流读入并解析 为一系列记号（token）并记录到符号表中；语法分析器（yacc, bison, ml-yacc, java-CC, ANTLR）将词法分析输出的记号作为输入生成具体语法树（Concrete syntax tree）；语义分析器以具体语法树为输入，输出抽象语法树（Abstract syntax tree），检查语义错误，重载等；优化器进行与机器无关的优化，输出语义上等价的抽象语法树；地址分配，映射变量到静态区、栈区、堆区；生成机器代码，选择合适指令，寄存器分配，指令调度器。</p><img src="Compiler_design.svg" alt="Compiler Design" style="zomm:%100;"><img src="The structure of a compiler.png" alt="Compiler Structure " style="zomm:%100;"><img src="Compiler structure.svg" alt="Compiler Structure" style="zomm:%100;"><img src="Xxx_Scanner_and_parser_example_for_C.gif" alt="Xxx Scanner and parser example for C" style="zomm:%100;"><p>编译器维护管理着一个符号表（symbol table）分为全局符号表和有作用域范围的符号表，符号表的实现可以使用线性链表、二叉搜索树、哈希表，大多以哈希表的方式实现。与编译器实现有关，符号表格式一般为：&lt;symbol name,  type,  attribute&gt;或&lt;symbol name,  attribute&gt;，可以用一个有继承关系的数据结构表示，其实现可以用栈结构、链表结构，栈：一个作用域创建一个符号表并保存到栈中，链表：将所有符号表保存在一个链表中，用栈指向当前活动作用域。</p><img src="symbol_table.jpg" alt="Symbol Table" style="zomm:%100;"><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>方舟编译器从架构看吸取了LLVM的一些思想，统一建模创建了IR语言，直接将代码编译为机器代码消除了虚拟机JIT编译的消耗，而在Android系统中app运行依赖于虚拟机的，如何实现兼容性。（Dalvik、ART）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Opensource-license</title>
      <link href="/2021/10/10/opensource-license/"/>
      <url>/2021/10/10/opensource-license/</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>现今软件开发不可避免的会用到开源软件，开源软件的使用则涉及到开源许可证的限制，了解遵守许可是必要的。各个许可的差异主要有是否允许修改、新增代码许可类型、是否允许商用等。 开源许可是一种法律许可，通过该许可规范了使用者如何使用开源产品以及应承担许可要求的义务。 开源一般分为开源软件、开源硬件、开源设计、开源内容，一般指开源软件。</p><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p> [开源促进会](<a href="https://opensource.org/licenses/alphabetical">Licenses by Name | Open Source Initiative</a>)（OSI，Open Source Initiative）批准的大致百来种，主要有MIT、BSD、Apache、GPL等。<a href="mulanos.oschina.net">木兰社区</a>制定的<a href="license.coscl.org.cn">木兰协议</a></p><p>已通过OSI认证。木兰社区尽管由官方牵头，目前公司、组织、个人参与度并不高，开源项目亦有限。以下分别是Whitesource、 Github、 Backduck 做的许可使用率的调查。</p><img src="PERMISSIVE-VS-COPYLEFT-LICENSES-2016.jpg" alt="Permissive Copyleft License" style="zomm:%100;"><img src="github-repo-license-num-2015.png" alt="Github License" style="zomm:%100;"><img src="blackduck-opensource-license-2014.png" alt="Blackduck License" style="zomm:%100;"><h3 id="主要许可比较"><a href="#主要许可比较" class="headerlink" title="主要许可比较"></a>主要许可比较</h3><img src="opensource-license-comparison.png" alt="License Comparison" style="zomm:%100;"><p>GPL(GNU General Public License)</p><p>GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。GPL协议的主要内容是只要在一个软件中使用(”使用”指类库引用，修改后的代码或者衍生代码)GPL协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源和免费。这就是所谓的”传染性”。</p><p>LGPL(GNU Lesser General Public License)</p><p>LGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。</p><p>Apache Licence</p><p>Apache Licence是著名的非盈利开源组织Apache采用的协议。鼓励代码共享和尊重原作者的著作权，允许代码修改，再发布(作为开源或商业软件)。需要给代码的用户一份Apache Licence，如果你修改了代码，需要在被修改的文件中说明。在延伸的代码中(修改和有源代码衍生的代码中)需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改。</p><p>BSD开源协议</p><p>BSD开源协议是一个给于使用者很大自由的协议。基本上使用者可以”为所欲为”，可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。BSD代码鼓励代码共享，但需要尊重代码作者的著作权。如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。</p><p>MIT(MIT)</p><p>MIT是和BSD一样宽范的许可协议，作者只想保留版权，而无任何其他了限制.也就是说，你必须在你的发行版里包含原许可协议的声明，无论你是以二进制发布的还是以源代码发布的。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>开源项目、组织有哪些</p>]]></content>
      
      
      
        <tags>
            
            <tag> Open Source </tag>
            
            <tag> License </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Portability-compatibility</title>
      <link href="/2021/10/01/portability-compatiblity/"/>
      <url>/2021/10/01/portability-compatiblity/</url>
      
        <content type="html"><![CDATA[<p>兼容性和可移植性是软件开发中重要目标，Windows、Linux取得成功的一关键原因就在两者尽可能保证了应用的可移植性和兼容性。</p><p>兼容、可移植性主要涉及源码、编译器、操作系统、硬件等方面。</p><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><p>当前主要有ARM、x86、PowerPC、MIPS、RISC-V等架构的CPU。</p><p>ARM：高级精简指令集机器（Advanced RISC Machine），指令集采用定长架构（thumb为变长指令集），大致有50条指令，广泛应用于低功耗移动设备。V6前不支持内存非对齐访问，之后有条件支持非对齐内存访问。指令中包含4bit条件执行的编码。</p><img src="ARMSoCBlockDiagram.svg" alt="ARM Architecture" style="zomm:%100;"><p>X86：指令集使用变长的CISC架构，硬件采用普林斯顿架构（冯诺依曼架构）</p><img src="Athlon_arch.png" alt="Athlon arch" style="zomm:%100;"><p>MIPS：采用RISC指令集架构，最新架构版本于2014年推出 ，现该架构已不再更新，但其衍生架构（龙芯、RISC-V）仍在发展中。</p><img src="MIPS_Architecture_(Pipelined).svg" alt="MIPS_Architecture_Pipelined" style="zomm:%100;"><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>开发过程中尽可能使用标准明确的、确定的语句，避免使用依赖编译器、操作系统特性的代码。对于一些强依赖于操作系统、硬件的代码一般做法是增加适配层（VOS）。因此实现可移植性则需要抽象、分层、隔离差异，如Linux不同硬件平台差异代码放在arch目录，对文件系统，设备的抽象分层处理。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>x86、ARM架构占有大部分市场，RISC-V开源架构有哪些优势，还有机会发展为硬件开源中的“Linux”吗</p>]]></content>
      
      
      
        <tags>
            
            <tag> Portability </tag>
            
            <tag> Compatibility </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Serial-communication</title>
      <link href="/2021/09/28/serial-communication/"/>
      <url>/2021/09/28/serial-communication/</url>
      
        <content type="html"><![CDATA[<p>Serial通信一般分为同步通信（SPI、I^2C）和异步通信（UART），硬件上主要区别是同步通信总线上有单独的同步时钟线，在数据链路层，异步通信数据帧上需添加额外信息（起始位、停止位、空闲位）用于同步数据帧。逻辑信号表示分为single-ended和differential，差分信号有较好抗噪声、传输距离更长优点正逐步替代单端模式。</p><h2 id="Asynchronous-Communication"><a href="#Asynchronous-Communication" class="headerlink" title="Asynchronous Communication"></a>Asynchronous Communication</h2><p>UART：通用异步收发器，一般指串口、总线标准有EIA RS-232  、EIA RS-485、RS-422，是早期计算机最早的通信设备之一，应用十分广泛。</p><p>CAN：控制器局域网，由BOSCH公司开发，利用message identifier定义内容和消息优先顺序进行传输。当前使用较多的规范11位标识符的CAN2.0 A和29位标识符的CAN2.0B。ISO于1993年公布了can标准ISO11898。</p><p>Ethernet：以太网通信规范，现互联网使用较为普遍的通信标准，10BASE-T使用manchester编码，100BASE-T使用4B5B编码，1000BASE-T（IEEE802.3ab）使用PAM-5编码。</p><p>Firewire：”火线“是苹果公司对IEEE 1394标准的命名，该标准的提出与USB有着相似目的，早期1394标准速度优于USB。</p><p>SATA：一种用于连接主机总线和大容量存储设备的总线接口。</p><p>SAS：序列化SCSI（Serial Attached SCSI）一种点对点的串行协议，由并行SCSI发展而来。主要用作连接计算机周边设备如硬盘、CD-ROM，进行数据传输。</p><h3 id="电路电平"><a href="#电路电平" class="headerlink" title="电路电平"></a>电路电平</h3><p>RS232电平范围-15到15V，采用负逻辑。RS485使用差分信号表示，电平范围-7到12V。</p><img src="Rs232_Rs485_standard.PNG" alt="Rs232 Rs485 Standard" style="zomm:%100;"><p>CAN电平范围0~5V，使用differential模式以dominant state （逻辑0，diff v:2.0v）和 recessive state（逻辑1，diff v:0v）两种状态表示逻辑信号。</p><img src="ISO11898-2.svg" alt="CAN standard logic level" style="zomm:%100;"><p>常见TTL（7000 series）、CMOS（4000 series）</p><img src="Standard Logic Levels.PNG" alt="Standard Logic Levels" style="zomm:%100;"><h3 id="信号波形"><a href="#信号波形" class="headerlink" title="信号波形"></a>信号波形</h3><p>Rs232发送’K’字符（0x4B）波形如下图：</p><img src="Rs232_oscilloscope_trace.svg" alt="Rs232 waveform" style="zomm:%100;"><p>Rs485发送0xD3波形如下图：</p><img src="RS-485_waveform.svg" alt="Rs485 waveform" style="zomm:%100;"><p>CAN波形：</p><p>CAN采用NRZ编码，为维护帧同步一般会对数据帧进行位填充。</p><img src="CAN-Bus-frame_in_base_format_without_stuffbits.svg" alt="CAN waveform without stuffbits" style="zomm:%100;"><img src="CAN-Frame_mit_Pegeln_mit_Stuffbits.svg" alt="CAN waveform with stuffbits" style="zomm:%100;"><h3 id="常见电平转换芯片"><a href="#常见电平转换芯片" class="headerlink" title="常见电平转换芯片"></a>常见电平转换芯片</h3><p>232转ttl电平：max232（MAXIM），SP3232E（SIPEX）</p><p>usb转ttl：PL2303HX（Prolific）、CH340（沁恒）、XR21V1410（MaxLinear）、FT232（FTDI）、CP2104（SILICON LABS）</p><h2 id="Synchronous-Communication"><a href="#Synchronous-Communication" class="headerlink" title="Synchronous Communication"></a>Synchronous Communication</h2><p>HDMI：高清多媒体接口（High Definition Multimedia Interface）该接口实现了 EIA/CEA-861标准，用于传输音视频数据。</p><p>PCIE：高速串行计算机扩展总线标准。（PCI：Peripheral Component Interconnect，外设组件互连总线）</p><p>SPI：串行外设接口（Serial Peripheral Interface），一种短距离的同步串行通信接口规范，主要用于嵌入式系统中。使用主从架构，工作在全双工模式。</p><p>SPI　master－slave连接示意图</p><img src="SPI_8-bit_circular_transfer.svg" alt="SPI　schematic" style="zomm:%100;"><p>SPI　时序图</p><img src="SPI_timing_diagram2.svg" alt="SPI　timing　diagram" style="zomm:%100;"><p>I^2C：集成电路总线（Inter-Integrated Circuit），是一种同步、多主多从，single-ended串行通信总线。广泛应用于外设集成电路和mcu之间的一种短距离板级通信协议。</p><img src="Basics-of-I2C-Communication-Data-Transfer-Protocol.jpg" alt="I2C frame format" style="zomm:%100;"><img src="I2C.svg" alt="I2C schematic" style="zomm:%100;"><img src="I2C_data_transfer.svg" alt="I2C timing diagram" style="zomm:%100;"><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>Rs232为何采用负逻辑</p><p>异步通信与同步通信（SPI、I^2C）的主要区别</p><p>PCI发展到PCI-e，并行SCSI发展到串行SCSI，即串行总线代替并行总线速度反而提高</p>]]></content>
      
      
      
        <tags>
            
            <tag> Serial Communication </tag>
            
            <tag> Synchronous </tag>
            
            <tag> Asynchronous </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Router introduction</title>
      <link href="/2021/08/08/router-introduction/"/>
      <url>/2021/08/08/router-introduction/</url>
      
        <content type="html"><![CDATA[<p>随着信息化发展，路由器肩负着数据交换重任，是现代通信网不可或缺的基石</p><h1 id="路由器介绍"><a href="#路由器介绍" class="headerlink" title="路由器介绍"></a>路由器介绍</h1><p>路由器作为ICT的一个最重要的基础设施，在在通信网络中扮演着十分重要的角色，从漂亮国打压菊厂的力度可见一斑。路由器作为网路设备， 处于OSI中的网络层，实现网路数据交换，他与交换机的区别主要是：交换机创造网络二路由器连接网络，路由器作为分发者，选择最优的路径传输数据，交换机（2层）工作在 数据链路层上，路由器则工作在网络层。路由器转发方式有进程转发、快速转发、优化转发、分布式转发，交换结构有共享内存型、总线型、cross-bar型。路由器的体系结构：路由器从单总线、单CPU结构发展到单总线、多CPU再到多总线多CPU，采用交叉开关方式。</p><h2 id="厂商"><a href="#厂商" class="headerlink" title="厂商"></a>厂商</h2><p>下图是一些主要的路由器生产厂商，此外|腾达、水星、博达、迅捷、华硕等也是比较常见的生产厂商，华硕和博通合作，在消费者领域发展迅猛。这些厂商以华为技术较为雄厚，其企业高端交换机如CloudEngine 16816，交换容量最高可达2870Tbps，转包率460800Mpps；路由器NetEngine 8000 X8，交换容量750.69 Tbps，转包率172,800 Mpps。</p><img src="router_company.svg" alt="路由器厂商" style="zoom:100%;"><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><img src="Router_hw_architecture_logical.png" alt="Router architecture" style="zomm:%100;"><img src="Router_hw_architecture_example.png" alt="Router architecture" style="zomm:%100;"><img src="Router_sw_architecture.png" alt="Router architecture" style="zomm:%100;"><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><table><thead><tr><th>模块</th><th>品牌</th><th>主要功能</th></tr></thead><tbody><tr><td>CPU（处理器）</td><td>博通、高通、联发科、瑞昱、Ralink、Marvell、Ubicon</td><td>对路由进程、路由算法、路由过滤、网络管理、配置管理、数据包转发等控制方面的处理</td></tr><tr><td>内存</td><td>金士顿、三星、美光、海力士</td><td>缓存</td></tr><tr><td>flash</td><td>金士顿、三星、美光、闪迪</td><td>存储路由器操作系统</td></tr><tr><td>无线芯片</td><td>博通、atheros、MTK、Lantiq</td><td>无线管理芯片，收发无线信号</td></tr><tr><td>功放芯片</td><td>skyworkks、Qorva、Qualcomm、Broadcom、Murata</td><td>发送、接收高频信号</td></tr><tr><td>Nvram</td><td>STM、Cypress Semiconductor、Maxim Integrated</td><td>保存配置文件</td></tr><tr><td>ROM</td><td>\</td><td>POST、Boost Strap代码、Mini OS</td></tr><tr><td>输入、出端口</td><td>\</td><td>一般由线卡提供，链路层封装、解封装，数据包分类、SLIP、PPP协议</td></tr></tbody></table><p>此外还有网络变压器、ASIC（交换芯片，一般用于高端产品）</p><h2 id="固件"><a href="#固件" class="headerlink" title="固件"></a>固件</h2><table><thead><tr><th>名称</th><th>开发者</th><th>开源协议</th><th>说明</th></tr></thead><tbody><tr><td>IOS</td><td>Cisco</td><td>闭源</td><td>用于Cisco产品的商业软件</td></tr><tr><td>OpenWrt</td><td>LEDE</td><td>GPL</td><td>基于Linux，其他组件可能使用不同开源协议，插件丰富，支持硬件较多</td></tr><tr><td>DD-WRT</td><td>BrainSlayer</td><td>GPL</td><td>基于Linux，LinSys迫于压力开源WRT54G/GS固件发展而来</td></tr><tr><td>Tomato</td><td>/</td><td>GPL</td><td>基于Linux，有HyperWRT发展而来，简单易用</td></tr><tr><td>Vyos</td><td>/</td><td>GPL</td><td>基于debian开源的网络操作系统，</td></tr><tr><td>Asuswrt-merlin</td><td>Eric Sauvageau</td><td>GPL</td><td>基于Asuswrt 二次开发</td></tr><tr><td>Padavan</td><td></td><td>GPL</td><td>基于华硕 RT-N56U 进行魔改，俗称华硕老毛子固件</td></tr></tbody></table><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="标准组织"><a href="#标准组织" class="headerlink" title="标准组织"></a>标准组织</h3><table><thead><tr><th>名称</th><th>主要委员会</th><th>主要（标准）协议</th></tr></thead><tbody><tr><td>IEEE<br>Institute of Electrical and Electronics Engineers<br>电气和电子工程师协会<br>面向电子电气工程、通讯、计算机工程、<br>计算机科学理论和原理研究的组织<br> <a href="http://www.ieee.org/">www.ieee.org</a></td><td>IEEE 754──浮点算法规范<br>IEEE 802──局域网及城域网<br>IEEE 802.11──无线网络<br>IEEE 802.16──无线寛频网络<br>IEEE 829──软件测试文书<br>IEEE 896──未来总线Futurebus<br>IEEE 1003──POSIX<br>IEEE 1076──VHDL（VHSIC硬件描述语言）<br>IEEE 1149.1──JTAG<br>IEEE 1275──Open Firmware<br>IEEE 1284──并口<br>IEEE P1363──公钥密码<br>IEEE 1364——Verilog硬件描述语言<br>IEEE 1394──串行总线“火线”<br>IEEE 1619──存储安全<br>IEEE 1901──PLC<br>IEEE 12207──软件生命周期过程（IT）</td><td>IEEE 802.1──高级接口High Level Interface(Internetworking)<br>IEEE 802.2──逻辑链路控制<br>IEEE 802.3──带冲突检测的载波侦听多路访问协议CSMA/CD（半双工以太网）<br>IEEE 802.4──令牌通行总线<br>IEEE 802.5──令牌通行环（Token-Passing Ring）<br>IEEE 802.6──城域网<br>IEEE 802.7──宽带局域网（Brandband LAN）<br>IEEE 802.8──光纤局域网<br>IEEE 802.9──集成数据和语音网络<br>IEEE 802.10──网络安全（Network Security）<br>IEEE 802.11──无线局域网络<br>IEEE 802.12──100VG-AnyLAN（Voice Grade - Sprache geeignet）<br>IEEE 802.14──有线电视<br>IEEE 802.15──无线个人局域网络<br>IEEE 802.16──无线寛频网络<br>IEEE 802.17──弹性分组环（Resilient Packet Ring）</td></tr><tr><td>IETF<br>Internet Engineering Task Force<br>互联网工程任务组<br>推动Internet标准规范制定的最主要的组织<br><a href="http://www.rfc-editor.org/">www.rfc-editor.org</a></td><td>Applications Area (app)<br>Internet Area (int)<br>Operations &amp; Network Management Area (ops)<br>Routing Area (rtg)<br>Real-time Applications and Infrastructure Area (rai)<br>Security Area (sec)<br>Transport and Services Area (tsv) – frequently also referred to as the “Transport Area”</td><td>几乎涵盖网路层以上协议</td></tr><tr><td>ITU<br>International Telecommunication Union<br>国际电信联盟<br>itu.int/ITU-T<br><a href="http://www.itu.int/rec/T-REC/en">www.itu.int/rec/T-REC/en</a><br>旨在促进国际上通信网络的互联互通。进行全球无线电频谱和卫星轨道的划分，制定技术标准以确保实现网络和技术的无缝互连。</td><td>A ITU-T工作组织，管理<br>B 表达式定义方法，符号和分类<br>C 通用电信统计学（General telecommunication statistics）<br>D 通用资费原则（General tariff principles）<br>E 全网络业务，电话业务，维护操作和人为因素<br>F 非电话电信服务 （Non-telephone telecommunication services）<br>G 传输系统和媒体，数据系统和网络（Transmission systems and media, digital systems and networks）<br>H 可视音频和多媒体系统（Audiovisual and multimedia systems）<br>I 综合业务数字网（Integrated services digital network）<br>J 电缆网络电视传输，声音节目和其他多媒体信号（Cable networks and transmission of television, sound programme and other multimedia signals）<br>K 抗干扰保护（Protection against interference）<br>L 户外电缆和元件的施工、安装和保护（Construction, installation and protection of cables and other elements of outside plant）<br>M 网络维护，国际传输系统电话电路电报传真和租用电路<br>O 计量设备规范Specifications of measuring equipment<br>P 电话传输质量，安装和本地网<br>Q 交换和信令 （Switching and signalling）<br>R 电报传输（Telegraph transmission）<br>S 电报业务无终端设备（Telegraph services terminal equipment）<br>T 远程信息处理业务终端（Terminals for telematic services）<br>U 电报交换（Telegraph switching）<br>V 电话网上的数据通信（Data communication over the telephone network）<br>X 数据网和开放系统通信（Data networks and open system communications）<br>Y 全球信息基础架构和网络协议特征（Global information infrastructure and Internet protocol aspects）<br>Z 电信系统语言和通用软件特征（Languages and general software aspects for telecommunication systems ）</td><td>V.24、H.264、E.164……</td></tr><tr><td>ISO<br>International Organization for Standardization<br>国际标准化组织<br><a href="http://www.iso.org/">www.iso.org</a><br>制定全世界工商业国际标准的国际标准建立机构。</td><td></td><td>ISO 9000、编码标准……</td></tr><tr><td>EIA、TIA、ANSIC</td><td></td><td>EIA-232、EIA-422、EIA-485、TIA/EIA-568（RJ45）、ANSIC编码、ANSIC C……</td></tr></tbody></table><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><p>Ethernet II、IEEE 802.3标准的区别：1、帧格式不同 6（DMAC）+6（SMAC）+2（Type/Length）；2、制定者不同；3、使用范围不同，Ethernet II使用更加广泛。MTU：46-1500，两者都采用CSMA-CD（Carrier Sense Multiple Access with Collision Detection ）技术</p><img src="network_proto_model.svg" alt="Network protocol model" style="zomm:%100;"><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>为何MTU最小是46，最大是1500</p>]]></content>
      
      
      
        <tags>
            
            <tag> NetWork </tag>
            
            <tag> Router </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
